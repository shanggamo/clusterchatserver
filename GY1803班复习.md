# 三个重要的基础知识点

## 进程虚拟地址空间

前提：32位硬件体系   32位Linux内核    4G    用户空间3G    内核空间1G

应用程序工作在用户空间

操作系统工作在内核空间

用户空间划分：1.0x08048000开始存放   2. text、rodata   3、data bss  4.heap   5.共享库(*.so)  6.stack  7.命令行参数 8.环境变量

内核空间划分：1.ZONE_DMA(16M)  2.ZONE_NORMAL(896M).text .rodata.data.bss heap stack 3.ZONE_HIGHMEM(112M)   高端内存区域（内核空间地址映射采用线性映射，不同于用户空间基于二级页表映射，所以内核要映射1G以上的物理内存，需要借助ZONE_HIGHMEM）

所有进程的用户空间是私有的，内核空间是共享的。进程间的通信方式（匿名管道，命令管道，消息队列，共享内存，信号量）

32位Linux系统下，函数运行要分配栈（高 - 低）空间，系统默认的栈空间的大小是8M     pthread_create 3G / 8M = 384 

malloc/new heap（低 - 高）

**虚拟内存**

一种现代操作系统（windows和linux）内存管理方式

1. 给系统创建的每一个进程提供特定大小的虚拟地址空间
2. 保证了所有进程地址空间-用户空间部分是隔离的，不能互相访问
3. 当物理内存不够使用的情况下，缺页异常处理程序再分配物理页面，内核就会根据LRU算法，把闲置的物理页面（脏页），写入到磁盘的swap交换分区当中，然后再进行物理页面分配



## 函数的调用过程

ebp和esp指针来标识一个函数的栈底和栈顶  main  ->  sum(int a, int b)

1. 从右向左把sum函数的实参入栈
2. 把call指令的下一行指令地址压入栈
3. push ebp  把main函数栈底地址入栈
4. mov ebp, eap 让ebp指针指向sum函数的栈底
5. sub esp, 4Ch  相当于给sum开辟栈帧
6. rep stos指令（for） 给ebp<->esp之间的栈内存初始化0xCCCCCCCC（VS上做  GCC&G++不做栈的初始化）
7. 执行sum函数的指令，直到右括号处
8. mov esp, ebp  让esp指向sum的栈底
9. pop ebp  出栈（main函数栈底地址），把出栈的值赋给ebp，ebp就指向了main函数栈底   因为出栈，esp+=4
10. ret  出栈（下一行指令地址），赋给CPU的PC寄存器
11. esp += 8 把sum函数的形参内存释放



## C&CPP代码编译链接运行过程描述

**编译** ： 一个工程的所有源文件（*.c  *.cpp *.cc  *.h *.hpp）是独立编译的

1.预处理（预编译）：以#号开头的预处理指令，如#include #define #ifdef #else #elif #endif   除#progma（链接so库，需要保留到链接阶段），删除注释

2.编译阶段：语法，语义分析检查，代码优化(gcc -O2)，汇总所有的符号（函数符号，变量的符号）

3.汇编阶段：把汇编指令转成本地平台的机器码，生成obj文件的各个段（text data bss 符号表。。。）

4.生成二进制可重定位的目标文件   

​                    ============================》  符号表中所有的符号没有分配虚拟地址 

**链接**：

1.合并所有obj文件+*.a（静态库）的各个段，包括text,data,bss。。。。其中符号表合并开始做符号解析（所有对符号的引用，都要在其它obj文件中找到该符号的定义），符号解析完成，给所有符号分配虚拟地址

2.符号的重定向（因为符号都有虚拟地址了，然后去text代码段，把所有符号的地址更新成符号的正确地址就可以了）

3.生成依赖于本地平台的可执行文件（.exe[PE格式]     a.out[ELF格式]）

**运行**：

1.只把可执行文件的text、rodata、data、bss映射到虚拟地址空间上（实际上未分配过任何物理内存）

2.在文件头中，读取程序的入口地址（main函数的入口地址），放入CPU的PC寄存器当中

3.开始运行，执行指令或者访问数据（需要在内存上按地址访问一条指令或者一个数据）。CPU发出的是虚拟地址，要经过MMU做地址映射操作（页目录页表映射），因为没有分配过物理页面，所以肯定会发生缺页异常，转入linux内存的缺页异常处理程序do_page_fault进行异常处理，分配响应的物理页面，把物理页面的信息写入响应的页表项当中，然后重启地址映射过程，肯定能够映射成功，然后访问物理内存上存储的指令或者数据。



# C&CPP的区别

1. 带默认值参数的函数

2. inline函数（C99开始有了）

   inline只是对编译器的一个函数的建议，最终由编译器决定

   inline是编译阶段处理的，在函数调用点，把函数代码展开，省了函数的调用开销

   因为inline是编译阶段展开函数代码，所以inline函数不产生符号

   inline函数只在release下起作用，debug不会内联

   inline函数可以调试的，#define定义的函数代码不能调试

3. const

   C语言的const定义的是常变量，它除了不能作为左值，其它和普通变量一模一样

   C++语言的const定义的是常量，它在编译时期，所有使用常量名字的地方，都会被常量的初始值进行替换（常量的初始值必须是一个明确的数字）

   C++中const定义的常量，有时候会退化成常变量（用变量的值初始化一个常量）

4. const和*和**指针类型转换的几大错误

   const int * -> int *

   const int ** -> int **

   int ** -> const int **

   int * const * -> int**

5. new和delete   malloc和free

   **new和malloc的区别**

   malloc是C的库函数，new是一个运算符重载函数operator new

   malloc按字节开辟内存，内存开辟失败返回nullptr；new按类型开辟内存空间，内存开辟失败抛出bad_alloc类型的异常

   malloc只能开辟内存，不能初始化；new不但可以可以内存，还可以初始化（new一个数组，只能默认初始化 new int[10]  new int[10] ()）

   new底层实际上调用的就是malloc，但调用完malloc，new还会自动调用初始化操作

   **delete和free的区别**

   free是C的库函数，delete是一个运算符的重载函数operator delete

   free只能释放内存，而delete会先析构，再释放内存（free）

   free不区分单个元素和数组内存释放；而delete需要区分，因为单个元素和数组元素调用的析构函数是不一样多的

6. namespace名字空间作用域

   C语言只有函数的局部作用域和全局作用域
   C++语言由函数的局部作用域、全局的名字空间作用域、类的作用域

   using声明： using std::cout;  using std::cin; using std::endl;

   #include <iostream>

   std::cout << "hello world" << std::endl;

   using指示符：using namespace std;

7. C++函数支持函数模板

   写一套函数代码，可以用任意的类型进行实例化，非常适合做泛型编程

   模板是编译阶段实例化，每一种类型都会实例化一个模板函数

8. 函数重载

   C语言不支持函数重载，是因为C编译器根据函数名生成符号，所有函数名是不能相同的；C++语言支持重载，是因为C++编译器是根据函数名和形参列表生成函数符号的，所以：

   1.一组函数名相同，参数列表不同的函数，构造一组函数重载

   2.函数重载，需要这些函数先处在同一个作用域

   C++怎么调用C写的函数：把C的头文件，函数声明等括在extern "C"里面

   C怎么调用C++些的函数：把C++所有的源码，都括在extern "C"里面

   #ifdef __cplusplus

   extern "C"

   {

   #endif

   int sum(int a, int b);

   #ifdef __cplusplus

   extern "C"

   }

   #endif

# C++类和对象

1.成员变量     初始化    构造函数的初始化列表  构造函数的函数体

普通成员变量

const成员变量

static成员变量   =》  必须在类外初始化

2.成员方法

普通成员方法 ： 用对象调用    编译会生成this指针

const成员方法 ： 用对象调用   编译会生成 const 类类型 *this

static成员方法 ：用类作用域调用   没有this指针，调用不依赖于对象



构造函数可以重载，提供多个；析构函数只能有一个。全局对象程序开始运行就构造，程序结束析构；堆上的对象new的时候构造，delete的时候析构；栈上的对象执行到它定义时构造，出作用域析构。



对象如果发生浅拷贝产生重复释放外部资源的问题，除了的方式有

1. 把拷贝构造和operator=私有化声明
2. 利用C++11特性把拷贝构造和operator=两个函数进行delete
3. 自定义拷贝构造和operator=两个函数（最好提供这两个函数相应的带右值引用参数的拷贝构造和operator=）



问题：实现拷贝构造函数的时候，能不能按值接收实参String(String str)，不能，因为形参对象也需要调用拷贝构造函数本身，编译不通过！



对象的声明周期！！！参考网上课堂的讲解还有课堂的代码示例！    =>  未完待续！

   