# 深入学习C++需要掌握的三块内容

## 进程虚拟地址空间

前提：32位CPU  32位linux内核

2^32（4G）的虚拟地址空间，分别包括用户空间（3G）和内核空间（1G），每一个进程用户空间是私有的，内核空间是共享的

用户空间：0x08048000开始  .text  .rodata   .data .bss  heap  共享库区域(*.so)  stack  命令行参数 环境变量PATH

内核空间：ZONE_DMA(16M) Direct Memory Access    ZONE_NORMAL(896M) .text .rodata. heap stack 

ZONE_HIGHMEM(高端内存   用户空间采用的地址映射方式是二级页表映射，而内核空间的地址映射方式采用的线性映射，那么1G以上的物理内存如何进行映射，就靠这块高端内存区域了)



堆内存heap分配，从低地址 到 高地址；栈内存stack的分配，从高地址到低地址。data段的内存程序启动时候分配，程序运行结束内存释放；heap内存是在调用new或者malloc的时候分配，调用delete或者free的时候释放；调用函数分配新的栈空间，函数出右括号占内存释放。



32位linux创建进程fork（资源划分的单位）的上限：0-32767    进程间的通信（匿名管道、命令管道、消息队列、共享内存、信号量）；创建线程pthread_create，一个进程创建线程的上限数量是多少（线程栈的大小是8M），3G / 8M = 384 ，如果如何提高进程里面创建的线程的数量？？？用limit设置系统创建线程默认的线程栈的大小 



一个进程里面创建的线程，每一个线程都有自己的栈空间，但是各个线程共享当前进程的data和heap堆空间。多线程对比多进程的应用，其好处是线程间通信方式（sem）简单，方便共享变量（放在heap或者data），而且线程占用的资源少，所以线程的上下文切换所耗费的系统性能也少。



**虚拟内存**

虚拟内存是操作系统管理内存的一种方案，该方案至少提供了以下几点功能：

1. 给系统运行的每一个进程，都分配4G的虚拟地址空间
2. 保证了所有进程虚拟地址空间的用户空间是隔离的，不能够互相访问
3. 放物理内存紧张的时候，再需要分配物理内存，系统会根据LRU（最近最久未使用）算法，把相应的物理页面（dirty脏页面-数据被修改过的页面）写入磁盘的swap交换分区当中（产生磁盘I/O），后面如果再需要使用这一块页面的数据，又会从磁盘的swap交换分区当中把数据再读回物理页面当中



## 函数详细的调用过程

main -> sum(int a, int b) 函数的运行，系统是需要分配一块栈空间的，系统通过CPU的ebp和esp指针来标识一个函数栈的栈底和栈顶。

1.从右向左的顺序把sum函数的实参一次入栈

2.把call指令的下一行指定的地址入栈

3.push ebp ： 把main函数的栈底地址入栈

4.mov ebp, esp： 让ebp指针指向sum函数的栈底

5.sub esp,4Ch ：给sum函数分配栈帧

6.rep stos（for）：把[ebp,esp]栈初始化成0xCCCCCCCC（windows的VS编译器会做函数栈的初始化）  gcc/g++不会做栈的初始化

7.执行sum函数的代码...直到sum函数的右括号

8.mov esp, ebp ： 把sum函数的栈帧归还给系统

9.pop ebp ： 出栈（把main函数的栈底地址出栈了），把出栈的元素赋给ebp，让ebp指向main函数的栈底地址

10.ret ： 出栈（把main函数中刚才调用sum的call指令的下一行指令地址出栈了），赋给CPU的PC寄存器

11.add esp, 8 ： 把sum函数的形参内存交还给系统



## C&C++源码编译链接运行的详细过程

**编译过程**：所有源文件都是分开编译

1.预处理阶段：删除注释，处理所有以#号开头的指令，但除了#progma(link, "动态库")这个指令是告诉编译器当前程序需要链接哪些库，所以该指令需要持续到链接阶段

2.语义，词法，语法分析，代码优化(gcc/g++ -O3)，最终生成汇编指令

3.把汇编代码生成本地（windows/linux）机器码，并形成组成.o文件的各个段（text data 符号表...）

4.编译最终生成二进制可重定位目标文件

**链接过程**：所有的.o文件.a文件是一起链接的

1.把所有.o文件和.a静态库文件的所有段进行合并，开始做符号解析（符号表中对符号的引用，一定要在其它的.o文件或者.a文件的符号表中找到符号的定义），符号解析完成，给所有的符号分配虚拟地址。

2.符号的重定向(经过符号解析，所有的符号都有虚拟地址了，再去text段把所有访问符号时，符号的正确地址更新上去)

3.产生可以运行在当前平台下的可执行文件 .exe elf格式的可执行文件

**运行过程**：

1.程序开始运行，把elf格式的可执行文件的text，data，bss映射到当前进程的虚拟地址空间上

2.从elf文件的hear头信息中，读取Entry Address（main函数第一行指令地址）写入CPU的PC寄存器当中

3.CPU开始读取PC寄存器的内容（就是main函数第一行指令地址），CPU发出的地址是虚拟地址，需要经过MMU（Memory Management Unit）做页目录页表映射（虚拟地址 -> 地址映射 -> 物理地址），此时的地址映射肯定会产生缺页异常，进入缺页异常处理程序(do_page_fault)，这个方法就会分配相应的物理页面，把磁盘上可执行文件的text段加载到刚分配的这块物理内存页面上，然后把物理页面的信息写入到相应的页表项当中，然后重启地址映射。